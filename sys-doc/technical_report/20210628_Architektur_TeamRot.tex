\documentclass[letterpaper, 10 pt, conference]{ieeeconf}
%\documentclass[a4paper, 10pt, conference]{ieeeconf}

\overrideIEEEmargins

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{hyperref}
\usepackage{url}
\usepackage{graphicx}
\usepackage{ngerman}

\hypersetup{hidelinks}

\title{\LARGE
\textbf{FireForceDefense} \\ Technical Report
}

\author{Cameron Barbee, Tim Hoffmann,  Christian Piffel,  Tobias Schotter,\\  Sebastian Schuscha,  Philipp Stangl,  Thomas Stangl%
}

\begin{document}

\maketitle
\thispagestyle{empty}
\pagestyle{empty}

\section{Einführung und Ziele}

Im vorliegenden Projekt soll das Tower-Defense-Spiel „FireForceDefense“ erweitert werden.
Ziel ist es, das Spiel um eine einfache Benutzerverwaltung, d.h. Registrierung und Anmeldung, zu ergänzen.
Außerdem soll eine Rangliste geschaffen werden, wofür eine Spielstand-Speicherung notwendig ist.

\section{Bausteinsicht}
Diese Sicht zeigt die statische Zerlegung des Systems in Bausteine sowie
deren Beziehungen.  %\cite{c1}

\begin{figure}[thpb]
      \centering
      \includegraphics[scale=0.38]{images/context}
      \caption{Kontextabgrenzung}
      \label{fig:context}
\end{figure}


\subsection{Gesamtsystem}
%Whitebox-Beschreibung des Gesamtsystems,
%zusammen mit Blackbox-Beschreibungen der darin enthaltenen Bausteine.
Die Anwendung basiert auf einer Client-Server-Architektur (\ref{fig:context}).
Frontend und Backend kommunizieren über eine RESTful-API.


\subsection{Frontend}
Dieser Abschnitt beschreibt die client-seitige Frontend-Architektur.
Das Frontend wird unter Zuhilfenahme des Frameworks Vue.js realisiert.

Es ist selbst in mehrere Unter-Bausteine zerlegt:

\subsubsection{Model}

Dieser Baustein enthält die Logik für den Problembereich im Frontend.
Die eigentlichen Anzeigekomponenten besitzen Referenzen auf die Instanzen der Klassen des Model-Bereichs,
sodass Eingaben an das Model weitergegeben und dort verarbeitet werden können.
Schließlich besitzt das Model Schnittstellen, mittels denen Informationen über den aktuellen Zustand abgefragt werden können,
um basierend darauf die Anzeige anzupassen.

Im Model ist beispielsweise die Spiellogik und die Schnittstelle zum Speichern und Abrufen von Spielständen verortet.

\subsubsection{Components}

In diesem Modul sind die Vue-Komponenten gesammelt, mit denen die eigentliche Anzeige im Webbrowser realisiert wird.
Die Komponenten sind dabei hierarchisch geordnet, so besteht ein Level beispielsweise aus einer Sidebar und der LevelMap, die LevelMap wiederum enthält einzelne Zellen und so weiter.
Die Komponenten behandeln alle Eingaben und senden bei Bedarf entsprechende Nachrichten an das Model.
Zusätzlich sind hier die neuen Vue-Komponenten für die Registrierung, die Anmeldung und die Rangliste hinterlegt.
Sowohl die Registrierung, als auch die Anmeldung verfügen über eine Validierung der Benutzereingaben durch geeignete regular expressions.

\subsubsection{SCSS}

Hier werden zentral genutzte Stile im SCSS-Format abgelegt.

\subsubsection{Lang}

Dieser Baustein ist für die Internationalisierung, genauer gesagt die Übersetzung, zuständig.
Aktuell ist lediglich eine deutsche Sprachvariante hinterlegt.

\subsubsection{Levels}

Dieses Modul enthält die Level-Definitionen.
Eine Level-Definition beschreibt den initialen Aufbau des Spielfelds und die auftretenden Effekte.
Jedes Level muss anhand der jeweiligen Definition im LevelManager des Model-Bereichs registriert werden.

\subsubsection{Cells, Contents und Effects}

In diesen drei Bausteinen sind die verschiedenen, konkreten Zell-, Inhalts- bzw. Effekt-Typen samt ihren jeweiligen Eigenschaften hinterlegt.

\subsubsection{Services}

Dieser Baustein wird im Frontend benötigt, um die relevanten Daten zur Registrierung bzw. zur Anmeldung, also den Nutzernamen, die Email-Adresse
sowie das Passwort eines Benutzers, an die RESTful-API zu übergeben.

\subsection{Backend}
Dieser Abschnitt beschreibt die server-seitige Backend-Architektur.

\subsubsection{Datenbank} \label{datenbank}

Die Speicherung der Daten erfolgt im dokumentenorientierten NoSQL-Datenbankmanagementsystem \textit{MongoDB}.
Zusätzlich wird die Bibliothek  \textit{mongoose} für das Object Data Modeling (ODM) verwendet. \\
Der folgende Teilbereich beschreibt die Unterteilung der Daten in drei Collections:

\begin{itemize}
\item
\textit{Accounts:} Hier werden die nötigen Informationen eines Benutzers gespeichert, um
eine Login- und Registrierungsfunktion zu gewährleisten. Das ist einerseits ein
einzigartiger Benutzername, eine E-Mailadresse, ein verschlüsseltes Passwort, sowie
ein Datum, welches den Registrierungszeitpunkt festhält.
\item
\textit{Refreshtokens:} In dieser Dokumentensammlung werden alle nötigen Informationen für
das Session-Handling gespeichert. Das ist einerseits die von MongoDB automatisch
erstellte ID der einzelnen Benutzer, um jedem Benutzer seinen entsprechenden Token
zuweisen zu können. Dazu wird der entsprechende Token mit Verfallsdatum
des Tokens,  Erstellungsdatum des Dokumentes und die IP des Erstellers gespeichert.
\item
\textit{Scores:} Diese Sammlung an Dokumenten speichert alle relevanten Aspekte des
Spielstandes. Einerseits den Benutzernamen, das Level, die erreichten Sterne, das
übriggebliebene Geld, sowie die verwendete Zeit und die Anzahl an verbrannten Zellen.
Diese Informationen bilden die Grundlage für die Erstellung der Rangliste.
\end{itemize}

\subsubsection{Laufzeitumgebung}

JavaScript-basierte Plattform Node.js mit dem serverseitigen Webframework ExpressJS.

\section{Verteilungssicht}
Das Verteilungssicht beschreibt die Verteilung des Gesamtsystems,  wichtige Begründungen für diese Verteilungsstruktur und die Zuordnung von Softwareartefakten zu Bestandteilen der Infrastruktur.
Zentrale Bestandteile der Verteilungsstruktur sind (A) das Kubernetes Cluster,  (B) das Datenbank-Cluster und (C) die GitLab CI/CD-Pipeline.  Die Verteilungsstruktur wird in Abbildung \ref{fig:infrastructure}  veranschaulicht.

\subsection{Kubernetes Cluster}

Für ein Kubernetes-Cluster wurde sich entschieden, aufgrund der Tatsache, das mehrere virtuelle Cluster (sog. Namespaces) auf demselben physischen Cluster unterstützt werden. Dadurch kann die CI/CD Pipeline im \textit{Gitlab-managed-apps} Namespace laufen, währenddessen die Anwendung auf einem anderen Namespace bereitgestellt wird.

Das Kubernetes Cluster wird über den „Elastic Kubernetes Service“ des Cloud-Providers Amazon Web Services bereitgestellt.  Aus datenschutzrechtlichen Gründen werden nur Cloud Server, die der Verfügbarkeitszone Frankfurt (eu-central-1) angehörig sind, verwendet.  Damit die Anwendung, insbesondere der Frontend-Service mit dem Nginx-Server öffentlich erreichbar ist, wird auf dem Cluster ein Application Load Balancer (AWS ALB-Ingress\cite{c1}) bereitgestellt.  Die Aufgabe des Load Balancings wird, basierend auf der Ingress-Ressource\cite{c2},  vollständig von AWS übernommen.  

\subsection{Datenbank-Cluster}
Das Datenbank-Cluster besteht aus drei Replikationen. Es stellt jeweils eine Datenbank für den Entwicklungs- und Produktionsbetrieb bereit. Näheres zur Datenbank wird im Abschnitt \ref{datenbank} erklärt.

\begin{figure*}[ht]
	\centering
	\includegraphics[width=\linewidth]{images/infrastructure}
	\caption{Cloud Infrastruktur}
	\label{fig:infrastructure}
\end{figure*}


\subsection{CI/CD-Pipeline}

Für die Bereitstellung der CI/CD Pipeline ist ein „Kubernetes-Executor“\cite{c3} auf dem Kubernetes Cluster verantwortlich.  Dieser verbindet sich mit der „Kubernetes Cluster API“ und erstellt einen Pod für jeden GitLab CI Job. Dieser Pod besteht aus einem Build-Container und einem zusätzlichen Container für jeden Service. Die Pipeline umfasst das Erstellen, Testen und Bereitstellen der Anwendung.  Folgende vier Stages durchläuft jeder \textit{Push} in das Gitlab-Repository:

\subsubsection{Dependencies}

Installation der npm-Pakete in das Verzeichnis node\_modules.

\subsubsection{Lint}

Durchführung statischer Code-Analysen.

\subsubsection{Build}

Alle notwendigen Bau-/Vorbereitungsaufgaben der Anwendung werden ausgeführt.

\subsubsection{Test}

Durchführung von Unit Tests, um die Korrektheit des Codes zu validieren.  \\

Die letzten beiden Stages werden nur im main-Zweig des Repositories durchlaufen, um die Anwendung für den Produktionsbetrieb bereitzustellen.

\subsubsection{Dockerize}

Wenn alle Unit Tests bestanden sind, wird für Front- und Backend jeweils ein Docker-Image gebaut. Anschließend werden beide Images im Docker-Registry (Amazon ECR) abgelegt, damit sie für die nächste Stage (Deploy) verfügbar sind.  Aufgrund fehlender Berechtigungen kann nicht von der privaten GitLab Container-Registry Gebrauch gemacht werden.

\subsubsection{Deploy}

In der letzten Phase werden die Docker Images aus der Docker-Registry auf dem Kubernetes Cluster als Container bereitgestellt. Die Anwendung ist dann,  bis einschließlich dem Tag der Präsentation, öffentlich zugänglich.


\section{Entwicklungsumgebung und Tools}

\subsection{IDE}

Das Projekt ist so ausgerichtet, dass es keine Beschränkung auf eine bestimmte IDE gibt.
Die meisten Teammitglieder verwenden JetBrains Phpstorm.

\subsection{Paketverwaltung}

Die Verwaltung der Abhängigkeiten erfolgt mit „npm“.

\subsection{Linting}

In beiden Unterprojekten (Frontend und Backend) wird jeweils „eslint“ in Verbindung mit „prettier“ verwendet,
um die Einhaltung der Codierrichtlinien zu gewährleisten.

Die Konfigurationen sind jeweils in den Dateien \texttt{eslintrc.js} und \texttt{prettierrc.js} hinterlegt.

\subsection{Build-Tools}

\subsubsection{Backend}

Im Backend wird der Typescript Compiler „tsc“ verwendet, um die Dateien in ein Format zu überführen,
welches mit \texttt{node} ausgeführt werden kann.

Die Konfiguration findet sich dabei in der Datei \texttt{tsconfig.json}.

\subsubsection{Frontend}

Im Frontend ist Webpack dafür zuständig, die Anwendung aus dem Quellcode zu erstellen.
Dabei gibt es zwei Varianten:
Für Entwicklungszwecke wird ein Webpack-Dev-Server (mit Reload-Funktionalität) zum Bereitstellen der Anwendung verwendet,
während für den Produktiveinsatz nur die benötigten Zieldateien erstellt werden, die dann mit einer beliebigen Server-Software ausgeliefert werden können.

Die Webpack-Konfiguration erfolgt in den \texttt{webpack.config.*.js}-Dateien.
Darin ist festgelegt, dass die CSS-Bestandteile in der Ausgabedatei \texttt{main.css} gesammelt werden.
Die Index-Datei und die Assets werden in das Ausgabeverzeichnis kopiert, die Vue-Single-File-Component-Dateien werden übersetzt
und Typescript wird zu JavaScript kompiliert.

Ferner sind Alias-Namen für häufig genutzte Verzeichnisse definiert, um Pfadangaben zu vereinfachen.

\subsection{Unit Tests}

Unit-Tests werden mit „Jest“ realisiert.
Snapshot-Tests für die Frontend-Komponenten sind dabei durch die Pakete „vue-jest“ und „vue-test-utils“ möglich.

\section{Detailinformationen}

Im Folgenden werden die beiden Bereiche „Session Handling“ und „Rangliste“, welche der Hauptfokus der diesjährigen Arbeiten waren, etwas genauer betrachtet.

\subsection{Session Handling}

Das Session Handling basiert auf dem Konzept der „Sliding-Sessions“.  Für die Implementierung des Konzepts werden „JSON-Web-Tokens“\cite{c4} verwendet. 

\subsubsection{Token-Arten}

Man unterscheidet zwischen folgenden zwei Token-Arten:

\begin{itemize}
\item 
\textit{Access Token:}\\
Enthalten alle notwendigen Informationen für den Zugriff auf eine Ressource.  Access Token sind kurzlebig und nur für 1 Stunde gültig.
\item 
\textit{Refresh Token:}\\
Enthalten Informationen, um einen neuen Access Token zu erhalten, nachdem der Alte abgelaufen ist, oder der erstmalige Zugriff auf eine Ressource vom Server angefordert wird.  Refresh Token sind langlebig und für 7 Tage gültig.
\end{itemize}

Jede Sitzung (engl. Session) läuft nach einer gewissen Zeit der Inaktivität ab. 
Verwendet der Benutzer einen abgelaufenen Access Token, wird die Sitzung als inaktiv betrachtet und ein neuer Access Token ist erforderlich.  Dieser kann mit einem Refresh Token, der auf dem Client als „HTTP-Only Cookie“ hinterlegt ist, bezogen werden (Cookie-based Session Management). Näheres zur Speicherung des Refresh Token befindet sich im Abschnitt \ref{refreshToken}.

\subsubsection{Sitzungskennung}

Eine Sitzungskennung wird einem Refresh Token zugeordnet. Die mit einer Sitzungskennung verbundenen Daten befinden sich in der Datenbank (siehe \ref{datenbank}). Eine Sitzungskennung ist:

\begin{itemize}
\item zufällig generiert durch einen „Pseudorandom number generator“ (PRNG).
\item im Cookie gespeichert.
\end{itemize}

\subsection{Rangliste}

Die Spielergebnisse werden nach der Beendigung eines jeden Levels als Dokument in der „scores“-Collection der MongoDB abgelegt.

Basierend darauf wird backendseitig eine GET-Schnittstelle bereitgestellt,
über welche – unter optionaler Angabe eines Levels, nach dem gefiltert werden soll – die aggregierten Spielstandsdaten abgefragt werden können.
Diese Aggregation führt dazu, dass es pro Benutzername einen Eintrag gibt, welcher die aufaddierte Gesamtzahl der erreichten Sterne,
die durchschnittlich benötigte Spieldauer, das durchschnittlich angesparte In-Game-Geld-Guthaben, sowie die durchschnittliche Anzahl der abgebrannten Felder enthält.

Auch die Sortierung erfolgt bereits im Backend, und zwar nach folgenden Kriterien (in absteigender Priorität geordnet):
Sternenanzahl (absteigend), Anzahl der verbrannten Felder (aufsteigend), Geld-Guthaben (absteigend) und Spielzeit (absteigend).

Im Frontend werden diese Daten durch eine HTTP-Anfrage beschafft und durch eine Vue-Komponente auf einer eigenen Seite angezeigt.
Dabei haben Benutzer*innen die Möglichkeit, entweder eine Gesamtansicht über alle Level hinweg oder eine nach einem bestimmten Level gefilterte Ansicht auszuwählen.

Die eigene Ranglisten-Position wird hervorgehoben und fixiert angezeigt.

\section{Sicherheitskonzepte}

Dieser Abschnitt beschreibt die angewendeten Sicherheitskonzepte, die für eine sichere Produktionsumgebung notwendig sind.

\subsection{Passwort Hashing}
Bei der Erstellung eines neuen Benutzerkontos wird vor der Speicherung in der Datenbank ein „Hash“ für das gesetzte Passwort berechnet. Vor dem Hashing wird eine zufällige Zeichenfolge, ein sogenannter „Salt“, dem Passwort hinzugefügt. Dadurch werden Kennwörter nicht jedes Mal auf dieselbe Weise gehasht. Somit können Angriffe wie Nachschlagetabellen, Wörterbuchangriffe oder Brute-Force unterbunden werden. 

Wenn ein Benutzer versucht sich anzumelden, wird der Hash des eingegebenen Kennworts mit dem in der Datenbank gespeicherten Hash verglichen.  Stimmen die Hashes überein, kann der Benutzer auf das Konto zugreifen.

\subsection{Refresh Token Speicherung} \label{refreshToken}
Refresh Token sind langlebig. Das bedeutet, wenn ein Client einen Refresh Token vom Server erhält, muss dieser Token sicher gespeichert werden, damit dieser nicht von potenziellen Angreifern entwendet werden kann. Wenn ein Refresh Token entwendet wird, kann er verwendet werden, um neue Access Token zu erhalten und auf Ressourcen zugreifen, bis der Refresh Token abläuft.  Deshalb werden Refresh Token als Cookie mit dem HttpOnly-Attribut gespeichert. Dies verhindert, dass mittels einem „Cross-Site-Scripting (XSS)“-Angriff die Sitzungskennung gestohlen werden kann. 

\vspace{3cm}

\begin{thebibliography}{99}

\bibitem{c1} AWS.  Application load balancing on Amazon EKS.  \url{https://docs.aws.amazon.com/eks/latest/userguide/alb-ingress.html}

\bibitem{c2} Kubernetes.  Ingress Ressource.  \url{https://kubernetes.io/docs/concepts/services-networking/ingress/#the-ingress-resource}

\bibitem{c3} GitLab.  Gitlab Runner: Kubernetes executor.  \url{https://docs.gitlab.com/runner/executors/kubernetes.html}

\bibitem{c4} JWT.  JSON-Web-Token: RFC 7519.  \url{https://datatracker.ietf.org/doc/html/rfc7519}

\end{thebibliography}

\newpage

\begin{figure*}[ht]
	\centering
	\includegraphics[width=\linewidth]{images/registration}
	\caption{Registrierung}
	\label{fig:registration}
\end{figure*}

\begin{figure*}[ht]
	\centering
	\includegraphics[width=\linewidth]{images/scoreboard}
	\caption{Rangliste}
	\label{fig:scoreboard}
\end{figure*}

\end{document}
